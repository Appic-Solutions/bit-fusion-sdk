type ApproveError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  AllowanceChanged : record { current_allowance : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  Expired : record { ledger_time : nat64 };
  InsufficientFunds : record { balance : nat };
};
type BuildData = record {
  rustc_semver : text;
  git_branch : text;
  pkg_version : text;
  cargo_target_triple : text;
  cargo_debug : text;
  pkg_name : text;
  cargo_features : text;
  build_timestamp : text;
  git_sha : text;
  git_commit_timestamp : text;
};
type Error = variant {
  Internal : text;
  InvalidNonce : record { got : nat64; minimum : nat64 };
  Icrc2ApproveError : ApproveError;
  InvalidTokenAddress;
  BftBridgeAlreadyRegistered : text;
  Icrc2TransferFromError : TransferFromError;
  NotAuthorized;
  AnonymousPrincipal;
  BftBridgeDoesNotExist;
  JsonRpcCallFailed : text;
  InsufficientOperationPoints : record { got : nat32; expected : nat32 };
  InvalidBftBridgeContract;
  InvalidBurnOperation : text;
};
type HttpHeader = record { value : text; name : text };
type HttpResponse = record {
  status : nat;
  body : vec nat8;
  headers : vec HttpHeader;
};
type Icrc2Burn = record {
  operation_id : nat32;
  from_subaccount : opt vec nat8;
  icrc2_token_principal : principal;
  recipient_address : text;
  amount : text;
};
type InitData = record {
  evm_principal : principal;
  signing_strategy : SigningStrategy;
  owner : principal;
  spender_principal : principal;
  log_settings : opt LogSettings;
};
type Interval = variant {
  PerHour;
  PerWeek;
  PerDay;
  Period : record { seconds : nat64 };
  PerMinute;
};
type Log = record { log : text; offset : nat64 };
type LogSettings = record {
  log_filter : opt text;
  in_memory_records : opt nat64;
  enable_console : bool;
};
type Logs = record { logs : vec Log; all_logs_count : nat64 };
type MetricsData = record {
  stable_memory_size : nat64;
  cycles : nat64;
  heap_memory_size : nat64;
};
type MetricsMap = record {
  map : vec record { nat64; MetricsData };
  interval : Interval;
  history_length_nanos : nat64;
};
type MetricsStorage = record { metrics : MetricsMap };
type Result = variant { Ok : nat32; Err : Error };
type Result_1 = variant { Ok : text; Err : Error };
type Result_2 = variant { Ok : Logs; Err : Error };
type Result_3 = variant { Ok; Err : Error };
type SigningKeyId = variant { Dfx; Production; Test; PocketIc; Custom : text };
type SigningStrategy = variant {
  Local : record { private_key : vec nat8 };
  ManagementCanister : record { key_id : SigningKeyId };
};
type TransferFromError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  InsufficientAllowance : record { allowance : nat };
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
type TransformArgs = record { context : vec nat8; response : HttpResponse };
service : (InitData) -> {
  get_curr_metrics : () -> (MetricsData) query;
  get_metrics : () -> (MetricsStorage) query;
  burn_icrc2 : (Icrc2Burn) -> (Result);
  get_bft_bridge_contract : () -> (opt text) query;
  get_canister_build_data : () -> (BuildData) query;
  get_evm_principal : () -> (principal) query;
  get_mint_order : (vec nat8, vec nat8, nat32) -> (opt vec nat8) query;
  get_minter_canister_evm_address : () -> (Result_1);
  get_owner : () -> (principal) query;
  ic_logs : (nat64, nat64) -> (Result_2);
  list_mint_orders : (vec nat8, vec nat8) -> (
      vec record { nat32; vec nat8 },
    ) query;
  register_evmc_bft_bridge : (text) -> (Result_3);
  set_evm_principal : (principal) -> (Result_3);
  set_logger_filter : (text) -> (Result_3);
  set_owner : (principal) -> (Result_3);
  transform : (TransformArgs) -> (HttpResponse) query;
}
